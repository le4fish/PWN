
0x10 首先了解函数调用栈的过程
函数调用栈是指程序运行时内存一段 连续的区域 ，用来保存函数运行时的状态信息，包括函数参数与局部变量等。

称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶。

在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。

函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。

callee是函数本身，caller是外部程序来说明调用此函数

0x11 函数状态主要涉及三个寄存器－－esp，ebp，eip
esp： 用来存储函数调用栈的 栈顶 地址，在压栈和退栈时发生变化。

ebp： 用来存储当前 函数状态 的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。

eip： 用来存储即将执行的 程序指令 的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，程序就得以连续执行指令。

关键在于esp数据和指令都有可能指向，而eip只指向下一条指令

0x12 创建
变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。

首先将caller的基地址存入 ebp ，然后将callee参数依次压栈（caller的局部变量）

再将caller进行调用之后的下一条指令地址作为 返回地址 压入栈内。这样caller的 eip 的信息得以保存

然后将当前的ebp 寄存器的值（也就是caller的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶（esp)的地址（callee的基地址）

再之后是将 callee 的局部变量等数据压入栈内。按上述流程继续。最后esp为callee局部变量

从栈底到栈顶：
1.下一指令地址
2.函数的基地址
3.函数局部变量
4.子函数。。。

0x13 执行
首先callee的局部变量会从栈内直接弹出，栈顶会指向callee的基地址。

然后将存储的caller的基地址从栈内弹出，并存到 ebp 寄存器内。这样caller的 ebp（基地址）信息得以恢复。

此时栈顶会指向返回地址，将返回地址从栈内弹出，并存到 eip 寄存器内。这样caller的 eip（指令）信息得以恢复。

 至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行caller的指令

0x20 栈溢出原理
当函数正在执行内部指令的过程中我们无法拿到程序的控制权，

只有在  发生函数调用  或者  结束函数调用  时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。

而控制程序执行指令最关键的寄存器就是 eip ，所以我们的目标就是让 eip 载入攻击指令的地址。

0x21 修改 eip 的准备

首先，在退栈过程中，返回地址会被传给 eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。

其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。




