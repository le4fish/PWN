
0x10 首先了解函数调用栈的过程(栈桢）
函数调用栈是指程序运行时内存一段 连续的区域 ，用来保存函数运行时的状态信息，包括函数参数与局部变量等。

称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶。

在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。

函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。

callee是函数本身，caller是外部程序来说明调用此函数

0x11 函数状态主要涉及三个寄存器－－esp，ebp，eip
esp： 用来存储函数调用栈的 栈顶 地址，在压栈和退栈时发生变化。

ebp： 用来存储当前 函数状态 的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。

eip： 用来存储即将执行的 程序指令 的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，程序就得以连续执行指令。

关键在于esp数据和指令都有可能指向，而eip只指向下一条指令

0x12 创建
变化的核心任务是将调用函数（caller）的状态保存起来（返回地址和基地址依次压栈），同时创建被调用函数（callee）的状态。



从栈底到栈顶：
1.调用函数参数（到1）
2.下一指令地址
3.函数的基地址
4.函数局部变量（1始）

0x13 执行
首先callee的局部变量会从栈内直接弹出，栈顶会指向callee的基地址。

然后将存储的caller的基地址从栈内弹出，并存到 ebp 寄存器内。这样caller的 ebp（基地址）信息得以恢复。

此时栈顶会指向返回地址，将返回地址从栈内弹出，并存到 eip 寄存器内。这样caller的 eip（指令）信息得以恢复。


0x20 栈溢出原理
当函数正在执行内部指令的过程中我们无法拿到程序的控制权，

只有在  发生函数调用  或者  结束函数调用  时，程序的控制权会在函数状态之间发生跳转，这时才可以通过  修改函数状态  来实现攻击。

而控制程序执行指令最关键的寄存器就是 eip ，所以我们的目标就是让 eip 载入攻击指令的地址。

0x21 修改 eip 的准备

首先，在退栈过程中，返回地址会被传给 eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。

其次，我们可以在溢出数据内包含一段攻击指令，也可以指向内存其他位置寻找可用的攻击指令。

0x22 栈溢出核心
函数改变时，eip 会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，

不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。

所以覆盖到的技术大概可以总结为：

    修改返回地址，让其指向溢出数据中的一段指令（shellcode）
    
    修改返回地址，让其指向内存中已有的某个函数（return2libc）
    
    修改返回地址，让其指向内存中已有的一段指令（ROP）
    
    修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）





