0x10 首先了解函数调用栈的过程
函数调用栈是指程序运行时内存一段 连续的区域 ，用来保存函数运行时的状态信息，包括函数参数与局部变量等。

称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶。

在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。

函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。

callee是函数本身，caller是外部程序来说明调用此函数

0x11 函数状态主要涉及三个寄存器－－esp，ebp，eip
esp： 用来存储函数调用栈的 栈顶 地址，在压栈和退栈时发生变化。

ebp： 用来存储当前 函数状态 的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。

eip： 用来存储即将执行的 程序指令 的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，程序就得以连续执行指令。

关键在于esp数据和指令都有可能指向，而eip只指向下一条指令

0x12 创建
变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。

首先将caller基地址存入 ebp ，然后将callee参数依次压栈

再将caller进行调用之后的下一条指令地址作为 返回地址 压入栈内。这样caller的 eip 的信息得以保存

然后将当前的ebp 寄存器的值（也就是caller的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶（esp)的地址（callee的基地址）







