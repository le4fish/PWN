在linux内核里中构造rop链，其实和用户空间里的基本原理不变。

一.要注意的是，内核空间基本都位于内存的高地址地区，和用户空间分离。并且，保护措施主要有 kaslr，smap，smep

kaslr
即kptr_ restrict指示是否限制通过/ proc和其他接口暴露内核地址。

    0：默认情况下，没有任何限制。
    1：使用％pK格式说明符打印的内核指针将被替换为0，除非用户具有CAP_ SYSLOG特权
    2：使用％pK打印的内核指针将被替换为0而不管特权。


SMAP(Supervisor Mode Access Prevention)和SMEP(Supervisor Mode Execution Prevention)
作用是      禁止内核访问用户空间的数据             和禁止内核执行用户空间的代码。

分别位于CR4寄存器 第21位 和 第20位
arm里面叫 PXN(Privilege Execute Never) 和PAN(Privileged Access Never)。

SMEP类似于前面说的NX，不过一个是在内核态中，一个是在用户态中。

和NX一样SMAP/SMEP需要处理器支持，可以通过cat /proc/cpuinfo查看，在内核命令行中添加nosmap和nosmep禁用。


二.相比用户态库函数，内核态的函数有了一些变化

    printf() -> printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果
    
    memcpy() -> copy_from_user()/copy_to_user()
    
        1.copy_from_user() 实现了将用户空间的数据传送到内核空间
      
        2.copy_to_user() 实现了将内核空间的数据传送到用户空间
        
    malloc() -> kmalloc()，内核态的内存分配函数，和 malloc() 相似，但使用的是 slab/slub 分配器
    
    free() -> kfree()，同 kmalloc()
    
从进程中获取shell，使用 system("/bin/sh") 函数；而想要获取root权限，就要使用 commit_creds(prepare_kernel_cred(0)) 来提权。

原型为 ：
    int commit_creds(struct cred *new)
    struct cred* prepare_kernel_cred(struct task_struct* daemon)

kernel 管理进程，因此 kernel 也记录了进程的权限。

两个函数的地址都可以在 /proc/kallsyms 中查看（较老的内核版本中是 /proc/ksyms),

并且在非root权限下，使用 sudo sysctl -w kernel.kptr_restrict=0 之后才能查看。
    
