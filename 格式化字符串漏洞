类似于printf（）这样的函数，
一般格式为printf（"%x",&a），前面的"%x"是后面的&a的格式化定义。
然而，却有printf（str）形式的代码，没有了前面的格式化定义，那么就有格式化漏洞。

介绍：
触发格式化漏洞还有两个条件，输出的str是可以控制的，找到想要内容的偏移值。

%x是查看该偏移值的地址，%s是查看该偏移值的地址的值，%n是将%前面的数值存入该偏移值的地址

偏移：
%n$s是直接查看指定第n个偏移值的地址的内容，偏移计数从零开始（因为第一位是返回地址不算，但有时偏移不确定），

由调试到call printf（）此步查看，也可以尝试调试输入 %p ，输出位为1

32位直接查看栈桢内偏移地址便可
64位还有前6个寄存器存参，栈桢从第七位开始（edi，esi，edx, ecx, r8, r9）

覆盖小数字（一定要写在最前面，%n是按字节读取计数）
格式形如: aa%n$naa

前面的aa表示2个字节，使计数器为2，后面的aa是为了补位。

在32位中，保证4+4字节，在64位中，保证8字节，防止偏移出错。

覆盖大数字（或地址)
如果%n前面有n个字节的字符，计数器会记下n，但这样记录大数字太繁杂，不太会成功，成功也会费时。

hh 对于整数类型，printf期待一个从char提升的int尺寸的整数型参数

h  对于整数类型，printf期待一个从short提升的int尺寸的整数型参数

%hhn向地址写入单字节，%hn向地址写入双字节。向每个地址输入的char可以c转换成int，此时的计数量也不会太大。


pwntools中有 

计算offset：
def exec_fmt(payload):
    p = process("a.out")
    p.sendline(payload)
    info = p.recv()
    p.close()
    return info

autofmt = FmtStr(exec_fmt)

%n的便易用法：
fmtstr_payload(偏移值，{偏移的地址值:想要修改成的内容}）


scanf函数中，可以输入 ./ 来strlen函数判断了他的长度，但fopen时不读入。
