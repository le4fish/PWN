
内存断点的实现方式：（为什么速度慢）

将你欲下断地址所在的内存页增加一个名为 PAGE_NOACCESS 的属性，这个属性会把当前内存页设为禁止任何形式的访问，如果进行访问会触发一个内存访问异常。

在这同时，OD开始捕获目标程序中出现的这个异常，并判断触发这个异常的位置是否跟你下断的地址相同，

如果相同则内存断点触发，暂停被调试程序的运行，否则放行。

补充|： 
1.内存断点很消耗资源，因为PAGE_NOACCESS属性一设置就是一整个内存页无法访问，

那么当程序访问该内存页中非断点地址的内容同样会触发异常，

这时OD收到异常后需要进行特殊处理，临时放行，非常消耗资源，甚至这使得内存断点在调试很多大型程序时慢到近乎不可用。 

2.虽然内存断点的效率经常很不理想，但是因为仅仅是修改了一个内存属性，所以内存断点可以下数量非常多、单断点范围非常大。这是它的优势。

3.只在写入时断下的内存断点通常是将内存属性设为 PAGE_EXECUTE_READ ，也就是不可写来实现的。对这种属性的内存进行写操作将会触发异常。




 硬件断点的实现方式：（断在线程）
 
 由硬件提供给我们的调试寄存器组，我们可以对这些硬件寄存器设置相应的值，然后让硬件帮我们断在需要下断点的地址。 
 
 Intel 80386以上的CPU 提供了调试寄存器以用于软件调试。
 
 i386和i486拥有6个（另外两个保留（4，5））调试寄存器：Dr0 ~ Dr7。 
 
 Dr0,Dr1,Dr2,Dr3是用于设置硬件断点的, 由于只有4个硬件断点寄存器,所以同时最多只能设置4个硬件断点。
 
 产生的异常是STATUS_SINGLE_STEP(单步异常)。 Dr7是一些控制位,用于控制断点的方式
